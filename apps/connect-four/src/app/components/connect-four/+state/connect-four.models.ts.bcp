
export enum CellState {
  EMPTY = 'empty',
  PLAYER1 = 'player1',
  PLAYER2 = 'player2',
}


export class Cell {
  state: CellState;

  constructor(
    state: CellState = CellState.EMPTY
  ) {
    this.state = state;
  }

  resetClone(): Cell {
    return new Cell(CellState.EMPTY);
  }
}



export class Grid {
  cells: Cell[][]; // row, column
  rows: number;
  columns: number;
  alignedCellsToWin: number;

  constructor(rows: number, columns: number, alignedCellsToWin: number);
  constructor(cells: Cell[][], alignedCellsToWin: number);
  constructor(...args: any[]) {
    if (
      (args.length === 2)
      && Array.isArray(args[0])
      && (typeof args[1] === 'number')
    ) {
      this.cells = args[0];
      this.alignedCellsToWin = args[1];
      // TODO should check the array structure
      this.rows = this.cells.length;
      this.columns = this.cells[0].length;
    } else if (
      (args.length === 3)
      && (typeof args[0] === 'number')
      && (typeof args[1] === 'number')
      && (typeof args[2] === 'number')
    ) {
      this.rows = args[0];
      this.columns = args[1];
      this.alignedCellsToWin = args[2];
      this.cells = Array.from({ length: this.rows }, () => {
        return Array.from({ length: this.columns }, () => {
          return new Cell();
        })
      })
    } else {
      throw new TypeError(`Invalid arguments`);
    }

    if (
      (this.rows < this.alignedCellsToWin)
      || (this.columns < this.alignedCellsToWin)
    ) {
        throw new RangeError(`Min grid size: ${ this.alignedCellsToWin }x${ this.alignedCellsToWin }`);
    }
  }

  getWinner(): CellState {
    for (let row = 0; row < this.rows; row++) {
      for (let column = 0; column < this.columns; column++) {
        const cellState = this.cells[row][column].state;
        if (cellState !== CellState.EMPTY) {

          // left to right
          if ((column + 3) < this.columns) {
            let aligned = 1;
            for (; aligned < this.alignedCellsToWin; aligned++) {
              if (this.cells[row][column + aligned].state !== cellState) {
                break;
              }
            }
            if (aligned === this.alignedCellsToWin) {
              return cellState;
            }
          }

          // top to bottom
          if ((row + 3) < this.rows) {
            let aligned = 1;
            for (; aligned < this.alignedCellsToWin; aligned++) {
              if (this.cells[row + aligned][column].state !== cellState) {
                break;
              }
            }
            if (aligned === this.alignedCellsToWin) {
              return cellState;
            }
          }

          // top left to bottom right
          if (
            ((column + 3) < this.columns)
            && ((row + 3) < this.rows)
          ) {
            let aligned = 1;
            for (; aligned < this.alignedCellsToWin; aligned++) {
              if (this.cells[row + aligned][column + aligned].state !== cellState) {
                break;
              }
            }
            if (aligned === this.alignedCellsToWin) {
              return cellState;
            }
          }

          // top right to bottom left
          if (
            ((column - 3) < this.columns)
            && ((row + 3) < this.rows)
          ) {
            let aligned = 1;
            for (; aligned < this.alignedCellsToWin; aligned++) {
              if (this.cells[row + aligned][column - aligned].state !== cellState) {
                break;
              }
            }
            if (aligned === this.alignedCellsToWin) {
              return cellState;
            }
          }
        }
      }
    }
  }

  resetClone(): Grid {
    return new Grid();
  }
}

export class ConnectFourGame {
  grid: Grid;
  winner: CellState;

  constructor(
    grid: Grid,
  ) {
    this.grid = grid;
    this.winner = this.grid.getWinner();
  }

  resetClone(): ConnectFourGame {

  }
}
